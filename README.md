# IterativeCUR_code
This directory contains all the code to replicate the experiments in ``Fast Rank Adaptive CUR via a Recycled Small Sketch". The plots are all made with pgfplots and can be generated by compiling the `iterativeCUR.tex` file in the `article` directory. The results can be replicated from various stages. We present these stages as steps 1-3. With step 1 being generating the plots from the `clean_csvs`, step 2 generating the `clean_csvs` from the raw `csvs`, and step 3 being generating the raw csvs from the matlab code.

## Step 1
To generate the plots from the clean csvs, copy the `src/clean_csvs` to the `article/csvs` directory then use pdflatex to compile the `iterativeCUR.tex` file.

## Step 2
To generate the clean csvs from the raw csvs, which can be found in src, you will need to have access to both R and matlab. The manuscript contains 4 sets of experiments. Three experiments can be generated using the `src/analysis.R` script. If you are unfamiliar with the use of `R` here is a useful [textbook](https://r4ds.had.co.nz) by Hadley Wickham. To run:
1. Set your working directory to `IterativeCUR_code/src/`
2. Install the `tidyverse` and `purrr` packages
3. Run `source(analysis.R)`
This will generate `clean_csvs` for the experiments in sections 5.1, 5.2, and 5.4. To generate the clean_csvs for section 5.3,
you will need to call the `src/selection_test.m` script. Calling this script will require to change parameters, which are described in lines 1-48.

## Step 3
If you would like to generate the raw csv files you will need to run `src/rigorous_test.m` and `src/rigorous_test_block.m` scripts. The easist manner to run these scripts is using the command line and calling the `src/test.sh` and `src/test_block_parallel.sh` scripts. These experiments could take a long time to run. When running `src/test_block_parallel.sh` you should  
1. Set your working directory to `IterativeCUR_code/src/`
2. Ensure that you have run permissions for the file
3. Run `./test_block_parallel.sh [Matrix Name]` replacing `[Matrix Name]` with the name of the matrix for which you are trying to replicate the experiment.

To use `src/rigorous_test.m` you should
1. Set your working directory to `IterativeCUR_code/src/`
2. Ensure that you have run permissions for the file
3. Edit the `test.sh` file with the appropriate parameters according to the comments in the file. 
4. Run `./test.sh [Matrix Name]` replacing `[Matrix Name]` with the name of the matrix for which you are trying to replicate the experiment.

# Running the code for your own matrices 
The code for Iterative_CUR in this directory is highly modular in that it is easy to plug in any
selection method that you see fit as long as it only returns the selected indices. You can find the 
`IterativeCUR` function as well as the `CUR` function inside of the `src/curers` directory. For the funtion to 
work properly you need to add all other relevant directories to your path by calling 
```
addpath("./curers")
addpath("./error_methods")
addpath("./index_selection")
addpath("./over_sample_res")
```
After doing this you can run the `IterativeCUR` function. This function will return 
five outputs the approximate error at each iteration, C, U(Q from QR factor of core), T (R from QR factor of core), and R.
You can reconstruct the approximation based on these outputs by calling `C / T * (U' * R)`. The function also has 8 inputs
1. `A` the matrix you are trying to approximate
2. `block_size` the size of the blocks you are using to form your approximation
3. `oversample_percent` for our experiments this is always zero for high accuracy approximations making this value non-zero could be usedul.
4. `oversample_residual` this should always be set to `@approx_error`
5. `over_sample_method` this should always be set to `@zero_residual`
6. `col_selection` the method you wish to use to select columns from our code could be `@idx_LU`, `@idx_QR`, or `@idx_OS`  
7. `row_selection` the method you wish to use to select rows from our code could be `@idx_LU`, `@idx_QR`, or `@idx_OS`  

You can also test your own index selection routine by implementing it so that it takes as inputs
1. `A` the matrix you wish to select columns from
2. `block_size` the number of columns you wish to select
3. `I` a preallocated vector of indices
4. `start` in I we wish to store the next `block_size` entries.
Your function should also return `I` and `start` where `I` contains the selected indices and any other indices and `start` is the index in I after the last stored index location.

You can also call the `cur` function which has the same outputs as IterativeCUR without the error. The inputs are 
1. `A` the matrix you are trying to approximate
2. `rows` the number of rows you wish to select
3. `cols` the number of cols you wish to select
4. `sketch` the size of the sketch you want to use when selecting columns
5. `col_selection` the method you wish to use to select columns from our code could be `@idx_LU`, `@idx_QR`, or `@idx_OS`  
6. `row_selection` the method you wish to use to select rows from our code could be `@idx_LU`, `@idx_QR`, or `@idx_OS`  

